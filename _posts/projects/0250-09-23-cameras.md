---
layout: project
permalink: /:title/
category: projects

meta:
  keywords: "unitree"

project:
  title: "Hacking Unitree Cameras"
  type: "Jekyll"
  url: "https://github.com/katie-hughes/UnitreecameraSDK"
  logo: "/assets/images/projects/unitree/disassembled_crop.jpg"
  tech: "Unitree, strace, GDB"

---

This post (still in progress) details efforts to completely eliminate the use of the UnitreeCameraSDK to stream from the onboard cameras on the Unitree Go1 robot. The goal was to completely replace the Jetson Nanos on the robot with fresh copies that don't contain any Unitree software. 

<br>

I was able to pinpoint the exact syscall at which the cameras are enabled through their camera SDK source code using `strace` and `gdb`. It is an `ioctl` call of the following format:
```
ioctl(5, UVCIOC_CTRL_QUERY, &query)
```
*  `5` is a file descriptor referring to `/dev/video0`, the streaming device about to be unlocked
*  `query` is a struct of type `uvc_xu_control_query`, defined in `/usr/include/linux/uvcvideo.h`
*  `query.unit = 3`
*  `query.selector = 5`
*  `query.query = 1`
*  `query.size = 64`

This syscall happens after a long stream of `UVIOC_CTRL_QUERY` that sets camera parameters. These are likely to be vendor specific and it is unclear specifically which of the proceeding queries are necessary for unlocking.

<br>

I wanted to create a simple C script that would perform the appropriate syscalls to unlock the cameras without the use of the UnitreeCameraSDK, but ran out of time and needed to focus on other aspects of my final project using this robot. I currently have a <a href="https://github.com/katie-hughes/UnitreecameraSDK" target="_blank"><u>simple script</u></a> that relies on their camera SDK, and will unlock the cameras by instantiating a camera object and promptly segfaulting the program (more info below). After this, you can stream from the cameras using native Linux tools like `ffmpeg` or ROS packages like `usb_cam` (work in progress on these steps for ROS 2 <a href="https://github.com/katie-hughes/unitree_stream_camera" target="_blank"><u>here</u></a>). I believe that completely eliminating the UnitreeCameraSDK from the Unitree Go1 allows for easier use of their onboard cameras and promotes open source development! 

## Details to replicate
First, connect to a Jetson Nano on the Go1. Make sure that you can see USB cameras via `lsusb` and video devices with `ls /dev/video*`. My standard way of testing the cameras was through the linux `ffmpeg` command on `/dev/video0` (the same will hold for `/dev/video1`).
```
$ ffmpeg -i /dev/video0 output0.mp4
```
If the cameras are "locked", this command will hang, and when you `CTRL-C` you will see the following error message with no data being encoded.
```
could not find codec parameters for stream 0 (Video: mjpeg, none(bt470bg/unknown/unknown), 1856s800): unspecified pixel format
```
Any other attempts to read from the cameras will similarly fail with no data being encoded. If the cameras are "unlocked", `ffmpeg` will start streaming data.

## Autostart

The first thing was determining what was activating the cameras, and the first place to look was the `Unitree/autostart` folder. If you disable this entire folder on a Jetson Nano by renaming it something else, completely power the dog off and on again, the cameras will be locked.

<br>

If you allow autostarting, then kill the camera processes manually and run the same command, the cameras are unlocked. Note that if you don't kill the camera processes, `ffmpeg` will fail because the video devices are occupied.

<br>

Next, I renamed only `Unitree/autostart/camerarosnode` and performed another hard poweroff. The cameras were locked, indicating that whatever was enabling the cameras was instantiated there. This pushed me to investigate the `UnitreeCameraSDK` outside of the context of ROS, since one of the first thing that node does is create a `UnitreeCam` object.

## UnitreeCameraSDK

All of this further investigation was done with the `Unitree/autostart` folder completely disabled. Upon boot, the cameras are locked. If you run any of the example scripts from `UnitreeCameraSDK` (say `example_getRawFrame`), and exit them cleanly (by pressing `ESC`), the cameras will stay locked. If you exit abruptly, with `CTRL-C` or by killing the process through a terminal, the cameras will be unlocked. 

<br>

This indicated to me that something in the `UnitreeCam` object constructor was setting appropriate camera parameters and something in the destructor was un-setting them. When the destructor gets called, it prints out:
```
“Unitree camera resource has been released”
```
which occurs after the camera parameters have been un-set.

<br>

I created two incredibly simple C++ functions to test this hypothesis. The first (below) results in device `/dev/video0` being locked as the destructor is able to get called.
```
int main{
	UnitreeCamera cam(0);
	return 1;
}
```
The following unlocks `/dev/video0` by segfaulting!
```
int main{
	UnitreeCamera cam(0);
	abort();
	return 1;
}
```
Equivalent functions can be used to unlock `/dev/video1` by instantiating `UnitreeCamera cam(1)`.

<br>

With an incredibly minimal program for testing, it was time to do a deep dive into what was happening in the instantiation.


<br><br>

