---
layout: project
permalink: /:title/
category: projects
# published: false

meta:
  keywords: "ROS"

project:
  title: "Quadruped Crowd Navigation"
  type: "Jekyll"
  url: "https://github.com/katie-hughes/unitree_crowd_nav"
  logo: "/assets/images/projects/crowdnav/dog-at-feet.jpg"
  tech: "ROS 2, C++, Optimal Control"

twomovingpedsoffboard: B1oihg262rQ
twostaticpedsoffboard: rSiHWG69YVA
onboard: BboH0EfObbY
fouronboard: aoRcOXswA70
orinnano: kkvdkUThQ_E
five_static_orin: ITsKZ7eEZUY

---

For my capstone project for my MS in Robotics degree at Northwestern University, I am implementing the Bayes Rule Nash Equilibrium (BRNE) algorithm onto a Unitree Go1 robot for efficient crowd navigation. This post is not complete as I am still actively working on this project!

<br>

{% include youtubePlayer.html id=page.fouronboard %}

<!-- <br> -->

<!-- {% include youtubePlayer.html id=page.onboard %} -->

<br>

# Algorithm

The BRNE algorithm was developed by Muchen Sun, my advisor for this project. The core idea of this algorithm is to model the strategy of each agent in the distribution space rather than a discrete path. A simple Bayesian update scheme to the distributions of each agent is guaranteed to converge to a global <a href="https://en.wikipedia.org/wiki/Nash_equilibrium" target="_blank"><u>Nash equilibrium</u></a> -- where each agent has an optimal path, and no strategy that any of the agents can take can improve their own trajectory.

<br>

The BRNE algorithm produces trajectories that minimize a cost function of the following form:

$$a_3 \cdot \left(2 - \frac{2}{1 + \exp\left(-a_1 \cdot d^{a_2}\right)} \right)$$

Where $$d$$ is the distance between two agents, and $$a_1$$, $$a_2$$, and $$a_3$$ are parameters that adjust how close the agents are willing to come to each other during their trajectory. This function can be thought of as the "risk" of this trajectory point.


![Description](/assets/images/projects/crowdnav/costs.gif)
<center><h6>Visualization of the cost function for the BRNE algorithm.</h6></center>

<br>

The first step in this algorithm is to generate trajectory samples for all agents. After this, the maximum cost for all trajectory samples between all pairs of agents is computed, which quantifies how "risky" each of these trajectories are. Finally, there is an iterative Bayesian update process which assigns a weight to every agents' possible trajectories. The optimal trajectory for each agent is the weighted sum of these samples. A simple example with two agents is outlined below. 

<br>

![Description](/assets/images/projects/crowdnav/BRNE-visualization.png)
<center><h6>In this example, two agents are in a hallway. The blue agent wants to walk to the right and the orange agent wants to walk to the left, and their nominal desired paths if no other agents were present are described by the dotted line. The left panel shows the randomly generated trajectory samples for each agent, and the right panel shows the optimal trajectories after 10 Bayesian updates. This also includes a final collision check to ensure that the samples that go out of the hallway's bounds are not considered. </h6></center>

<br>

My contribution to this algorithm has primarily involved converting existing code from Python to C++. The Python version of this algorithm uses Numba for optimization. This has successfully worked in field tests, but requires around 20 seconds every time running to compile. Additionally, through stress tests, I found that the runtime blows up when the algorithm has to consider more than 4 agents (including the robot). My C++ implementation of the algorithm uses the Armadillo library for the matrix operations of the BRNE algorithm as well as OpenMP for parallelization. This is comparable with the Numba version of the algorithm for small numbers of pedestrians, but does not see the massive spike that the Python implementation does after 4 agents. In practice, the algorithm should provide trajectory updates at around 10 Hz and should be able to handle up to 5 agents. The C++ algorithm is better suited for this purpose and also scales more efficiently if more agents need to be considered in the future. 

![Description](/assets/images/projects/crowdnav/brne_speed_errorbar_cutoff8.png)
<center><h6>These times were generated running the appropriate BRNE ROS node in simulation using 196 samples per agent and 25 timesteps per sampled trajectory. The scatterplot points are the average computation time and the errorbars are the standard deviation over 100 timer iterations. </h6></center>

# Perception

For localization and pedestrian tracking, I am using a ZED 2i camera from StereoLabs. This camera is mounted on the back of the Unitree and provides updates for both of these topics at 15 Hz.

<br>

# System Design

At its core, the BRNE algorithm requires pedestrian location data and odometry data. Then, when given a goal position, it can create a trajectory plan that avoids pedestrians. I am using the `unitree_nav` package 
(<a href="https://github.com/ngmor/unitree_nav" target="_blank"><u>available here</u></a>) to process the `cmd_vel` messages that are the result of the BRNE trajectory plan into high level Unitree commands used by their SDK to control the robot. 

![Description](/assets/images/projects/crowdnav/SystemDesignBase.png)
<center><h6>Base Level System Design</h6></center>

I currently, I am using a System76 Adder WS that is mounted onto the back of the Unitree to handle perception data from the ZED (odometry and pedestrian tracking) as well as the actual BRNE algorithm. This is because none of the boards inside of the Unitree (Jetson Nano, Jetson Xavier, and Raspberry Pi) are capable at performing these tasks at the necessary speed. While this performs all of the relevant computation onboard, there are some downsides to this approach. First, it was difficult to design a mount that securely held the laptop on the back of the robot. The robot also has trouble with agile movements and is more prone to falling over from imbalance. With all of the extra weight, the motors also overheat faster, and devices onboard the robot tend to fail sooner (namely the Raspberry Pi provided WIFI hotspot).

![Description](/assets/images/projects/crowdnav/LaptopMountDesign.png)
<center><h6>System design with an onboard laptop (thanks to Davin Landry for designing and printing the mount!)</h6></center>

I am in the process of swapping out the onboard laptop with an externally mounted Orin Nano board. This is able to provide the perception based updates at an appropriately fast rate (15 Hz) and will dramatically reduce the weight on the robot. The core BRNE algorithm executes on my external computer as the Orin Nano does not have good enough CPU for the trajectory optimization calculations. (In the future, it might be possible to use CUDA to optimize the performance of the algorithm to this device, and once again have everything onboard). I have run a number of tests with this system and have had successful results!

![Description](/assets/images/projects/crowdnav/OrinNanoDesign2.png)
<center><h6>System design with an onboard Orin Nano (thanks to David Dorf for designing and printing the mount!)</h6></center>

# Acknowledgments

*  <a href="https://muchen-sun.com/" target="_blank"><u>Muchen Sun</u></a>
*  <a href="https://murpheylab.github.io/" target="_blank"><u>Todd Murphey</u></a>
*  <a href="https://robotics.northwestern.edu/people/profiles/faculty/elwin-matt.html" target="_blank"><u>Matthew Elwin</u></a>
*  <a href="https://dlandry97.github.io/Davin_Landry/" target="_blank"><u>Davin Landry</u></a>
*  <a href="https://www.daviddorf.com/" target="_blank"><u>David Dorf</u></a>


<br>

# Video Archive
<br>
{% include youtubePlayer.html id=page.five_static_orin %}
<br>
{% include youtubePlayer.html id=page.orinnano %}
<br>
{% include youtubePlayer.html id=page.twostaticpedsoffboard %}
<br>
{% include youtubePlayer.html id=page.twomovingpedsoffboard %}
<br>
{% include youtubePlayer.html id=page.onboard %}




<br><br>

